(* Generated by ocaml-tree-sitter. *)
(*
   swift grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type optionally_valueful_control_keyword = [
    `Ret of Token.t (* "return" *)
  | `Cont of Token.t (* "continue" *)
  | `Brk of Token.t (* "break" *)
  | `Yield of Token.t (* "yield" *)
]
[@@deriving sexp_of]

type raw_str_part = Token.t
[@@deriving sexp_of]

type catch_keyword = Token.t
[@@deriving sexp_of]

type arrow_operator_custom = Token.t
[@@deriving sexp_of]

type conjunction_operator_custom = Token.t
[@@deriving sexp_of]

type minus_then_ws = Token.t
[@@deriving sexp_of]

type raw_str_interpolation_start = Token.t (* pattern \\#*\( *)
[@@deriving sexp_of]

type raw_str_end_part = Token.t
[@@deriving sexp_of]

type async_keyword_custom = Token.t
[@@deriving sexp_of]

type async_modifier = Token.t
[@@deriving sexp_of]

type parameter_modifier = [
    `Inout of Token.t (* "inout" *)
  | `ATes of Token.t (* "@escaping" *)
  | `ATau of Token.t (* "@autoclosure" *)
]
[@@deriving sexp_of]

type plus_then_ws = Token.t
[@@deriving sexp_of]

type integer_literal = Token.t
[@@deriving sexp_of]

type assignment_and_operator = [
    `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `EQ of Token.t (* "=" *)
]
[@@deriving sexp_of]

type raw_str_continuing_indicator = Token.t
[@@deriving sexp_of]

type mutation_modifier = [
    `Muta of Token.t (* "mutating" *)
  | `Nonm of Token.t (* "nonmutating" *)
]
[@@deriving sexp_of]

type as_custom = Token.t
[@@deriving sexp_of]

type import_kind = [
    `Typeas of Token.t (* "typealias" *)
  | `Struct of Token.t (* "struct" *)
  | `Class of Token.t (* "class" *)
  | `Enum of Token.t (* "enum" *)
  | `Prot of Token.t (* "protocol" *)
  | `Let of Token.t (* "let" *)
  | `Var of Token.t (* "var" *)
  | `Func of Token.t (* "func" *)
]
[@@deriving sexp_of]

type open_ended_range_operator_custom = Token.t
[@@deriving sexp_of]

type tok_choice_pat_3425898 = Token.t
[@@deriving sexp_of]

type ownership_modifier = [
    `Weak of Token.t (* "weak" *)
  | `Unow_7c8c304 of Token.t (* "unowned" *)
  | `Unow_e455cde of Token.t (* "unowned(safe)" *)
  | `Unow_8fda70e of Token.t (* "unowned(unsafe)" *)
]
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type binding_pattern_kind = [
    `Var of Token.t (* "var" *)
  | `Let of Token.t (* "let" *)
]
[@@deriving sexp_of]

type oct_literal = Token.t
[@@deriving sexp_of]

type multiplicative_operator = [
    `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
]
[@@deriving sexp_of]

type pat_97d645c = Token.t (* pattern `[^\r\n` ]*` *)
[@@deriving sexp_of]

type real_literal = Token.t
[@@deriving sexp_of]

type as_quest_custom = Token.t
[@@deriving sexp_of]

type hex_literal = Token.t
[@@deriving sexp_of]

type rethrows_keyword = Token.t
[@@deriving sexp_of]

type tok_dollar_pat_9d0cc04 = Token.t
[@@deriving sexp_of]

type bang = Token.t
[@@deriving sexp_of]

type else_ = Token.t
[@@deriving sexp_of]

type inheritance_modifier = [ `Final of Token.t (* "final" *) ]
[@@deriving sexp_of]

type where_keyword = Token.t
[@@deriving sexp_of]

type semi = Token.t
[@@deriving sexp_of]

type statement_label = Token.t
[@@deriving sexp_of]

type member_modifier = [
    `Over of Token.t (* "override" *)
  | `Conv of Token.t (* "convenience" *)
  | `Requ of Token.t (* "required" *)
]
[@@deriving sexp_of]

type pat_c332828 = Token.t (* pattern \$[0-9]+ *)
[@@deriving sexp_of]

type line_str_text = Token.t (* pattern "[^\\\\\"]+" *)
[@@deriving sexp_of]

type pat_888b548 = Token.t (* pattern \{[0-9a-fA-F]+\} *)
[@@deriving sexp_of]

type throws_keyword = Token.t
[@@deriving sexp_of]

type try_operator = [
    `Try of Token.t (* "try" *)
  | `TryB of Token.t (* "try!" *)
  | `TryQ of Token.t (* "try?" *)
]
[@@deriving sexp_of]

type bitwise_binary_operator = [
    `AMP of Token.t (* "&" *)
  | `BAR of Token.t (* "|" *)
  | `HAT of Token.t (* "^" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
]
[@@deriving sexp_of]

type comparison_operator = [
    `LT of Token.t (* "<" *)
  | `GT of Token.t (* ">" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GTEQ of Token.t (* ">=" *)
]
[@@deriving sexp_of]

type multi_line_str_text = Token.t (* pattern "[^\\\\\"]+" *)
[@@deriving sexp_of]

type function_modifier = [
    `Infix of Token.t (* "infix" *)
  | `Post of Token.t (* "postfix" *)
  | `Prefix of Token.t (* "prefix" *)
]
[@@deriving sexp_of]

type three_dot_operator_custom = Token.t
[@@deriving sexp_of]

type property_modifier = [
    `Static of Token.t (* "static" *)
  | `Dyna of Token.t (* "dynamic" *)
  | `Opt of Token.t (* "optional" *)
  | `Class of Token.t (* "class" *)
]
[@@deriving sexp_of]

type nil_coalescing_operator_custom = Token.t
[@@deriving sexp_of]

type default_keyword = Token.t
[@@deriving sexp_of]

type disjunction_operator_custom = Token.t
[@@deriving sexp_of]

type eq_custom = Token.t
[@@deriving sexp_of]

type special_literal = [
    `HASH_36725ee of Token.t (* "#file" *)
  | `HASH_ee0b998 of Token.t (* "#fileID" *)
  | `HASH_bd759bd of Token.t (* "#filePath" *)
  | `HASH_709af6a of Token.t (* "#line" *)
  | `HASH_be35129 of Token.t (* "#column" *)
  | `HASH_96a7ced of Token.t (* "#function" *)
  | `HASH_4d47dbe of Token.t (* "#dsohandle" *)
]
[@@deriving sexp_of]

type escaped_identifier = Token.t (* pattern "\\\\[0\\\\tnr\"'\\n]" *)
[@@deriving sexp_of]

type dot_custom = Token.t
[@@deriving sexp_of]

type as_bang_custom = Token.t
[@@deriving sexp_of]

type pat_f630af3 = Token.t (* pattern [^\r\n]* *)
[@@deriving sexp_of]

type eq_eq_custom = Token.t
[@@deriving sexp_of]

type pat_9d0cc04 = Token.t (* pattern [_\p{XID_Start}][_\p{XID_Continue}]* *)
[@@deriving sexp_of]

type bin_literal = Token.t
[@@deriving sexp_of]

type parameter_modifiers = parameter_modifier list (* one or more *)
[@@deriving sexp_of]

type additive_operator = [
    `Plus_then_ws of plus_then_ws (*tok*)
  | `Minus_then_ws of minus_then_ws (*tok*)
  | `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
]
[@@deriving sexp_of]

type setter_specifier = (mutation_modifier option * Token.t (* "set" *))
[@@deriving sexp_of]

type modify_specifier = (mutation_modifier option * Token.t (* "_modify" *))
[@@deriving sexp_of]

type custom_operator = (
    tok_choice_pat_3425898 (*tok*)
  * Token.t (* "<" *) option
)
[@@deriving sexp_of]

type possibly_async_binding_pattern_kind = (
    async_modifier (*tok*) option
  * binding_pattern_kind
)
[@@deriving sexp_of]

type postfix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `Bang of bang (*tok*)
]
[@@deriving sexp_of]

type locally_permitted_modifier = [
    `Owne_modi of ownership_modifier
  | `Prop_beha_modi of Token.t (* "lazy" *)
  | `Inhe_modi of inheritance_modifier
]
[@@deriving sexp_of]

type throws = [
    `Throws_kw of throws_keyword (*tok*)
  | `Rethrs_kw of rethrows_keyword (*tok*)
]
[@@deriving sexp_of]

type non_local_scope_modifier = [
    `Member_modi of member_modifier
  | `Visi_modi of (
        [
            `Public of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Inte of Token.t (* "internal" *)
          | `File of Token.t (* "fileprivate" *)
          | `Open of Token.t (* "open" *)
        ]
      * (Token.t (* "(" *) * Token.t (* "set" *) * Token.t (* ")" *)) option
    )
  | `Func_modi of function_modifier
  | `Muta_modi of mutation_modifier
  | `Prop_modi of property_modifier
  | `Param_modi of parameter_modifier
]
[@@deriving sexp_of]

type constructor_function_decl = (
    Token.t (* "init" *)
  * [ `Quest of Token.t (* "?" *) | `Bang of bang (*tok*) ] option
)
[@@deriving sexp_of]

type shebang_line = (Token.t (* "#!" *) * pat_f630af3 (*tok*))
[@@deriving sexp_of]

type simple_identifier = [
    `Pat_9d0cc04 of pat_9d0cc04 (*tok*)
  | `Pat_97d645c of pat_97d645c (*tok*)
  | `Pat_c332828 of pat_c332828 (*tok*)
  | `Tok_dollar_pat_9d0cc04 of tok_dollar_pat_9d0cc04 (*tok*)
]
[@@deriving sexp_of]

type str_escaped_char = [
    `Esca_id of escaped_identifier (*tok*)
  | `Uni_char_lit of (
        Token.t (* "\\" *) * Token.t (* "u" *) * pat_888b548 (*tok*)
    )
]
[@@deriving sexp_of]

type getter_effects =
  [ `Async_kw of async_keyword_custom (*tok*) | `Throws of throws ]
    list (* one or more *)
[@@deriving sexp_of]

type range_operator = [
    `Open_ended_range_op of open_ended_range_operator_custom (*tok*)
  | `Three_dot_op of three_dot_operator_custom (*tok*)
]
[@@deriving sexp_of]

type prefix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
  | `Bang of bang (*tok*)
  | `AMP of Token.t (* "&" *)
  | `TILDE of Token.t (* "~" *)
  | `Dot of dot_custom (*tok*)
  | `Custom_op of custom_operator
]
[@@deriving sexp_of]

type as_operator = [
    `As of as_custom (*tok*)
  | `As_quest of as_quest_custom (*tok*)
  | `As_bang of as_bang_custom (*tok*)
]
[@@deriving sexp_of]

type equality_operator = [
    `BANGEQ of Token.t (* "!=" *)
  | `BANGEQEQ of Token.t (* "!==" *)
  | `Eq_eq of eq_eq_custom (*tok*)
  | `EQEQEQ of Token.t (* "===" *)
]
[@@deriving sexp_of]

type bound_identifier = simple_identifier
[@@deriving sexp_of]

type line_string_content = [
    `Line_str_text of line_str_text (*tok*)
  | `Str_esca_char of str_escaped_char
]
[@@deriving sexp_of]

type multi_line_string_content = [
    `Multi_line_str_text of multi_line_str_text (*tok*)
  | `Str_esca_char of str_escaped_char
  | `DQUOT of Token.t (* "\"" *)
]
[@@deriving sexp_of]

type getter_specifier = (
    mutation_modifier option
  * Token.t (* "get" *)
  * getter_effects option
)
[@@deriving sexp_of]

type referenceable_operator = [
    `Custom_op of custom_operator
  | `Comp_op of comparison_operator
  | `Addi_op of additive_operator
  | `Mult_op of multiplicative_operator
  | `Equa_op of equality_operator
  | `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `Bang of bang (*tok*)
  | `TILDE of Token.t (* "~" *)
]
[@@deriving sexp_of]

type identifier = (
    bound_identifier
  * (dot_custom (*tok*) * bound_identifier) list (* zero or more *)
)
[@@deriving sexp_of]

type operator_declaration = (
    [
        `Prefix of Token.t (* "prefix" *)
      | `Infix of Token.t (* "infix" *)
      | `Post of Token.t (* "postfix" *)
    ]
  * Token.t (* "operator" *)
  * custom_operator
  * (Token.t (* ":" *) * bound_identifier) option
)
[@@deriving sexp_of]

type tuple_type_item_identifier = (
    Token.t (* "_" *) option
  * bound_identifier
  * Token.t (* ":" *)
)
[@@deriving sexp_of]

type navigation_suffix = (
    dot_custom (*tok*)
  * [ `Simple_id of bound_identifier | `Int_lit of integer_literal (*tok*) ]
)
[@@deriving sexp_of]

type precedence_group_attribute = (
    bound_identifier
  * Token.t (* ":" *)
  * [ `Simple_id of bound_identifier | `Bool_lit of boolean_literal ]
)
[@@deriving sexp_of]

type protocol_property_requirements = (
    Token.t (* "{" *)
  * [ `Getter_spec of getter_specifier | `Setter_spec of setter_specifier ]
      list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type non_constructor_function_decl = (
    Token.t (* "func" *)
  * [
        `Simple_id of bound_identifier
      | `Refe_op of referenceable_operator
      | `Bitw_bin_op of bitwise_binary_operator
    ]
)
[@@deriving sexp_of]

type availability_argument = [
    `Id_int_lit_rep_DOT_int_lit of (
        identifier
      * integer_literal (*tok*)
      * (Token.t (* "." *) * integer_literal (*tok*)) list (* zero or more *)
    )
  | `STAR of Token.t (* "*" *)
]
[@@deriving sexp_of]

type precedence_group_attributes =
  precedence_group_attribute list (* one or more *)
[@@deriving sexp_of]

type precedence_group_declaration = (
    Token.t (* "precedencegroup" *)
  * bound_identifier
  * Token.t (* "{" *)
  * precedence_group_attributes option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type annotated_inheritance_specifier = (
    attribute list (* zero or more *)
  * inheritance_specifier
)

and anon_choice_bound_id_COLON_exp_9957b83 = [
    `Simple_id_COLON_exp of (
        bound_identifier * Token.t (* ":" *) * expression
    )
  | `Exp of expression
  | `Rep1_simple_id_COLON of
      (bound_identifier * Token.t (* ":" *)) list (* one or more *)
  | `Rep1_simple_id_int_lit_rep_DOT_int_lit of (
        bound_identifier list (* one or more *)
      * integer_literal (*tok*)
      * (Token.t (* "." *) * integer_literal (*tok*)) list (* zero or more *)
    )
]

and anon_choice_equal_sign_exp_74a2b17 = [
    `Equal_sign_exp of (eq_custom (*tok*) * expression)
  | `Comp_prop of computed_property
]

and anon_choice_exp_764291a = [
    `Exp of expression
  | `Expr_hack_at_tern_bin_call of (
        expression * expr_hack_at_ternary_binary_call_suffix
    )
]

and array_type = (Token.t (* "[" *) * type_ * Token.t (* "]" *))

and assignment = (
    directly_assignable_expression * assignment_and_operator * expression
)

and associatedtype_declaration = (
    modifiers option
  * Token.t (* "associatedtype" *)
  * bound_identifier
  * (Token.t (* ":" *) * type_) option
  * type_constraints option
  * (eq_custom (*tok*) * type_) option
)

and attribute = [
  `Rectype of (
      Token.t (* "@" *)
    * user_type
    * (
          Token.t (* "(" *)
        * anon_choice_bound_id_COLON_exp_9957b83
        * (Token.t (* "," *) * anon_choice_bound_id_COLON_exp_9957b83)
            list (* zero or more *)
        * Token.t (* ")" *)
      )
        option
  )
]

and basic_literal = [
    `Int_lit of integer_literal (*tok*)
  | `Hex_lit of hex_literal (*tok*)
  | `Oct_lit of oct_literal (*tok*)
  | `Bin_lit of bin_literal (*tok*)
  | `Real_lit of real_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Str_lit of string_literal
  | `Nil of Token.t (* "nil" *)
]

and binary_expression = [
    `Mult_exp of (expression * multiplicative_operator * expression)
  | `Addi_exp of (expression * additive_operator * expression)
  | `Range_exp of (expression * range_operator * expression)
  | `Infix_exp of (expression * custom_operator * expression)
  | `Nil_coal_exp of (
        expression * nil_coalescing_operator_custom (*tok*) * expression
    )
  | `Check_exp of (expression * Token.t (* "is" *) * type_)
  | `Equa_exp of (expression * equality_operator * expression)
  | `Comp_exp of (expression * comparison_operator * expression)
  | `Conj_exp of (
        expression * conjunction_operator_custom (*tok*)
      * anon_choice_exp_764291a
    )
  | `Disj_exp of (
        expression * disjunction_operator_custom (*tok*) * expression
    )
  | `Bitw_oper of (expression * bitwise_binary_operator * expression)
]

and binding_kind_and_pattern = (
    possibly_async_binding_pattern_kind * no_expr_pattern_already_bound
)

and binding_pattern = (
    Token.t (* "case" *) option
  * binding_pattern_kind
  * no_expr_pattern_already_bound
)

and binding_pattern_no_expr = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bind_pat of binding_pattern
      | `Bound_id of bound_identifier
    ]
  * Token.t (* "?" *) option
)

and binding_pattern_with_expr = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bind_pat of binding_pattern
      | `Exp of expression
    ]
  * Token.t (* "?" *) option
)

and block = (Token.t (* "{" *) * statements option * Token.t (* "}" *))

and bodyless_function_declaration = (
    modifiers option
  * Token.t (* "class" *) option
  * modifierless_function_declaration_no_body
)

and call_expression = (expression * call_suffix)

and call_suffix = [
    `Value_args of expr_hack_at_ternary_binary_call_suffix
  | `Lambda_lit_rep_simple_id_COLON_lambda_lit of (
        lambda_literal
      * (bound_identifier * Token.t (* ":" *) * lambda_literal)
          list (* zero or more *)
    )
]

and capture_list = (
    attribute list (* zero or more *)
  * Token.t (* "[" *)
  * capture_list_item
  * (Token.t (* "," *) * capture_list_item) list (* zero or more *)
  * Token.t (* "]" *)
)

and capture_list_item = [
    `Self_exp of Token.t (* "self" *)
  | `Opt_owne_modi_simple_id_opt_equal_sign_exp of (
        ownership_modifier option
      * bound_identifier
      * (eq_custom (*tok*) * expression) option
    )
]

and catch_block = (
    catch_keyword (*tok*)
  * binding_pattern_no_expr option
  * where_clause option
  * function_body
)

and class_body = (
    Token.t (* "{" *)
  * class_member_declarations option
  * Token.t (* "}" *)
)

and class_declaration = (modifiers option * modifierless_class_declaration)

and class_member_declarations = (
    type_level_declaration
  * (semi (*tok*) * type_level_declaration) list (* zero or more *)
  * semi (*tok*) option
)

and computed_getter = (
    attribute list (* zero or more *)
  * getter_specifier
  * function_body option
)

and computed_modify = (
    attribute list (* zero or more *)
  * modify_specifier
  * function_body option
)

and computed_property = (
    Token.t (* "{" *)
  * [
        `Opt_stmts of statements option
      | `Rep_choice_comp_getter of
          [
              `Comp_getter of computed_getter
            | `Comp_setter of computed_setter
            | `Comp_modify of computed_modify
          ]
            list (* zero or more *)
    ]
  * Token.t (* "}" *)
)

and computed_setter = (
    attribute list (* zero or more *)
  * setter_specifier
  * (Token.t (* "(" *) * bound_identifier * Token.t (* ")" *)) option
  * function_body option
)

and constructor_suffix = [
    `Cons_value_args of constructor_value_arguments
  | `Lambda_lit of lambda_literal
]

and constructor_value_arguments = (
    Token.t (* "(" *)
  * interpolation_contents option
  * Token.t (* ")" *)
)

and control_transfer_statement = [
    `Throw_stmt of throw_statement
  | `Opti_valu_cont_kw_opt_exp of (
        optionally_valueful_control_keyword
      * expression option
    )
]

and deinit_declaration = (
    modifiers option
  * Token.t (* "deinit" *)
  * function_body
)

and dictionary_literal_item = (expression * Token.t (* ":" *) * expression)

and dictionary_type = (
    Token.t (* "[" *) * type_ * Token.t (* ":" *) * type_ * Token.t (* "]" *)
)

and direct_or_indirect_binding = (
    [
        `Bind_kind_and_pat of binding_kind_and_pattern
      | `Case_bind_pat_no_expr of (
            Token.t (* "case" *) * binding_pattern_no_expr
        )
    ]
  * type_annotation option
)

and directly_assignable_expression = [
    `Simple_id of bound_identifier
  | `Navi_exp of navigation_expression
  | `Call_exp of call_expression
  | `Tuple_exp of tuple_expression
  | `Self_exp of Token.t (* "self" *)
]

and do_statement = (
    Token.t (* "do" *)
  * function_body
  * catch_block list (* zero or more *)
)

and else_options = [ `Blk of function_body | `If_stmt of if_statement ]

and enum_class_body = (
    Token.t (* "{" *)
  * [
        `Enum_entry of enum_entry
      | `Type_level_decl of type_level_declaration
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and enum_entry = (
    modifiers option
  * Token.t (* "indirect" *) option
  * Token.t (* "case" *)
  * bound_identifier
  * enum_entry_suffix option
  * (Token.t (* "," *) * bound_identifier * enum_entry_suffix option)
      list (* zero or more *)
  * Token.t (* ";" *) option
)

and enum_entry_suffix = [
    `Enum_type_params of (
        Token.t (* "(" *)
      * (
            tuple_type_item_identifier option
          * type_
          * (eq_custom (*tok*) * expression) option
          * (
                Token.t (* "," *)
              * tuple_type_item_identifier option
              * type_
              * (eq_custom (*tok*) * expression) option
            )
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Equal_sign_exp of (eq_custom (*tok*) * expression)
]

and expr_hack_at_ternary_binary_call_suffix = value_arguments

and expression = [
    `Choice_simple_id of [
        `Simple_id of bound_identifier
      | `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Tern_exp of ternary_expression
      | `Prim_exp of primary_expression
      | `Assign of assignment
      | `Exp_imme_quest of (expression * Token.t (* "?" *))
      | `Async of Token.t (* "async" *)
    ]
  | `Semg_ellips of three_dot_operator_custom (*tok*)
]

and for_statement = (
    Token.t (* "for" *)
  * try_operator option
  * Token.t (* "await" *) option
  * binding_pattern_no_expr
  * type_annotation option
  * Token.t (* "in" *)
  * expression
  * where_clause option
  * function_body
)

and function_body = block

and function_declaration = (bodyless_function_declaration * function_body)

and function_type = (
    tuple_type
  * async_keyword_custom (*tok*) option
  * throws option
  * arrow_operator_custom (*tok*)
  * type_
)

and function_value_parameter = (
    attribute option
  * parameter
  * (eq_custom (*tok*) * expression) option
)

and function_value_parameters = (
    Token.t (* "(" *)
  * (
        function_value_parameter
      * (Token.t (* "," *) * function_value_parameter)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and guard_statement = (
    Token.t (* "guard" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * else_ (*tok*)
  * function_body
)

and if_condition_sequence_item = [
    `If_let_bind of (
        direct_or_indirect_binding * eq_custom (*tok*) * expression
    )
  | `Exp of expression
  | `Avai_cond of (
        Token.t (* "#available" *)
      * Token.t (* "(" *)
      * availability_argument
      * (Token.t (* "," *) * availability_argument) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and if_statement = (
    Token.t (* "if" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * function_body
  * (else_ (*tok*) * else_options) option
)

and import_declaration = (
    modifiers option
  * Token.t (* "import" *)
  * import_kind option
  * identifier
)

and inheritance_specifier = [
    `User_type of user_type
  | `Func_type of function_type
]

and inheritance_specifiers = (
    annotated_inheritance_specifier
  * (
        [ `COMMA of Token.t (* "," *) | `AMP of Token.t (* "&" *) ]
      * annotated_inheritance_specifier
    )
      list (* zero or more *)
)

and interpolation = (
    Token.t (* "\\(" *) * interpolation_contents * Token.t (* ")" *)
)

and interpolation_contents = (
    value_argument
  * (Token.t (* "," *) * value_argument) list (* zero or more *)
)

and key_path_component = [
    `Simple_id_rep_key_path_postfs of (
        bound_identifier
      * key_path_postfixes list (* zero or more *)
    )
  | `Rep1_key_path_postfs of key_path_postfixes list (* one or more *)
]

and key_path_postfixes = [
    `QMARK of Token.t (* "?" *)
  | `Bang of bang (*tok*)
  | `Self of Token.t (* "self" *)
  | `LBRACK_opt_value_arg_rep_COMMA_value_arg_RBRACK of (
        Token.t (* "[" *)
      * interpolation_contents option
      * Token.t (* "]" *)
    )
]

and labeled_statement = (
    statement_label (*tok*) option
  * [
        `For_stmt of for_statement
      | `While_stmt of while_statement
      | `Repeat_while_stmt of repeat_while_statement
      | `Do_stmt of do_statement
      | `If_stmt of if_statement
      | `Guard_stmt of guard_statement
      | `Switch_stmt of switch_statement
    ]
)

and lambda_function_type = (
    [
        `Lambda_func_type_params of lambda_function_type_parameters
      | `LPAR_opt_lambda_func_type_params_RPAR of (
            Token.t (* "(" *)
          * lambda_function_type_parameters option
          * Token.t (* ")" *)
        )
    ]
  * async_keyword_custom (*tok*) option
  * throws option
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
)

and lambda_function_type_parameters = (
    lambda_parameter
  * (Token.t (* "," *) * lambda_parameter) list (* zero or more *)
)

and lambda_literal = (
    Token.t (* "{" *)
  * capture_list option
  * (lambda_function_type option * Token.t (* "in" *)) option
  * statements option
  * Token.t (* "}" *)
)

and lambda_parameter = (
    attribute option
  * [
        `Self_exp of Token.t (* "self" *)
      | `Simple_id of bound_identifier
      | `Opt_simple_id_simple_id_COLON_opt_param_modifs_poss_impl_unwr_type of (
            bound_identifier option
          * bound_identifier
          * Token.t (* ":" *)
          * parameter_modifiers option
          * possibly_implicitly_unwrapped_type
        )
    ]
)

and local_declaration = [
    `Local_prop_decl of (
        locally_permitted_modifiers option
      * modifierless_property_declaration
    )
  | `Local_typeas_decl of (
        locally_permitted_modifiers option
      * modifierless_typealias_declaration
    )
  | `Local_func_decl of (
        locally_permitted_modifiers option
      * modifierless_function_declaration
    )
  | `Local_class_decl of (
        locally_permitted_modifiers option
      * modifierless_class_declaration
    )
]

and local_statement = [
    `Exp of expression
  | `Local_decl of local_declaration
  | `Labe_stmt of labeled_statement
  | `Cont_tran_stmt of control_transfer_statement
]

and locally_permitted_modifiers =
  [ `Attr of attribute | `Loca_perm_modi of locally_permitted_modifier ]
    list (* one or more *)

and modifierless_class_declaration = [
    `Choice_class_simple_id_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_class_body of (
        [
            `Class of Token.t (* "class" *)
          | `Struct of Token.t (* "struct" *)
        ]
      * bound_identifier
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * class_body
    )
  | `Exte_user_type_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_class_body of (
        Token.t (* "extension" *)
      * user_type
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * class_body
    )
  | `Opt_indi_enum_simple_id_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_enum_class_body of (
        Token.t (* "indirect" *) option
      * Token.t (* "enum" *)
      * bound_identifier
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * enum_class_body
    )
]

and modifierless_function_declaration = (
    modifierless_function_declaration_no_body * function_body
)

and modifierless_function_declaration_no_body = (
    [
        `Cons_func_decl of constructor_function_decl
      | `Non_cons_func_decl of non_constructor_function_decl
    ]
  * type_parameters option
  * function_value_parameters
  * async_keyword_custom (*tok*) option
  * throws option
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
  * type_constraints option
)

and modifierless_property_declaration = (
    possibly_async_binding_pattern_kind
  * no_expr_pattern_already_bound
  * type_annotation option
  * type_constraints option
  * anon_choice_equal_sign_exp_74a2b17 option
  * (
        Token.t (* "," *)
      * no_expr_pattern_already_bound
      * type_annotation option
      * type_constraints option
      * anon_choice_equal_sign_exp_74a2b17 option
    )
      list (* zero or more *)
)

and modifierless_typealias_declaration = (
    Token.t (* "typealias" *)
  * bound_identifier
  * type_parameters option
  * eq_custom (*tok*)
  * type_
)

and modifiers =
  [
      `Non_local_scope_modi of non_local_scope_modifier
    | `Rep1_choice_attr of locally_permitted_modifiers
  ]
    list (* one or more *)

and navigable_type_expression = [
    `User_type of user_type
  | `Array_type of array_type
  | `Dict_type of dictionary_type
]

and navigation_expression = (
    [ `Navi_type_exp of navigable_type_expression | `Exp of expression ]
  * navigation_suffix
)

and no_expr_pattern_already_bound = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bound_id of bound_identifier
    ]
  * Token.t (* "?" *) option
)

and parameter = (
    bound_identifier option
  * bound_identifier
  * Token.t (* ":" *)
  * parameter_modifiers option
  * possibly_implicitly_unwrapped_type
  * three_dot_operator_custom (*tok*) option
)

and possibly_implicitly_unwrapped_type = (type_ * Token.t (* "!" *) option)

and primary_expression = [
    `Tuple_exp of tuple_expression
  | `Basic_lit of basic_literal
  | `Lambda_lit of lambda_literal
  | `Spec_lit of special_literal
  | `Play_lit of (
        [
            `HASH_38ce0d0 of Token.t (* "#colorLiteral" *)
          | `HASH_34ae46a of Token.t (* "#fileLiteral" *)
          | `HASH_71f9c0e of Token.t (* "#imageLiteral" *)
        ]
      * Token.t (* "(" *)
      * bound_identifier
      * Token.t (* ":" *)
      * expression
      * (
            Token.t (* "," *) * bound_identifier * Token.t (* ":" *)
          * expression
        )
          list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `Array_lit of (
        Token.t (* "[" *)
      * (
            expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Dict_lit of (
        Token.t (* "[" *)
      * [
            `COLON of Token.t (* ":" *)
          | `Dict_lit_item_rep_COMMA_dict_lit_item of (
                dictionary_literal_item
              * (Token.t (* "," *) * dictionary_literal_item)
                  list (* zero or more *)
            )
        ]
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Self_exp of Token.t (* "self" *)
  | `Super_exp of Token.t (* "super" *)
  | `Try_exp of (
        try_operator
      * [
            `Exp of expression
          | `Bin_exp of binary_expression
          | `Call_exp of call_expression
          | `Tern_exp of ternary_expression
        ]
    )
  | `Await_exp of (
        Token.t (* "await" *)
      * [
            `Exp of expression
          | `Call_exp of call_expression
          | `Tern_exp of ternary_expression
        ]
    )
  | `Refe_op of referenceable_operator
  | `Key_path_exp of (
        Token.t (* "\\" *)
      * [
            `Simple_user_type of simple_user_type
          | `Array_type of array_type
          | `Dict_type of dictionary_type
        ]
          option
      * (Token.t (* "." *) * key_path_component) list (* zero or more *)
    )
  | `Key_path_str_exp of (
        Token.t (* "#keyPath" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
  | `Three_dot_op of three_dot_operator_custom (*tok*)
]

and property_declaration = (
    modifiers option
  * modifierless_property_declaration
)

and protocol_body = (
    Token.t (* "{" *)
  * protocol_member_declarations option
  * Token.t (* "}" *)
)

and protocol_declaration = (
    modifiers option
  * Token.t (* "protocol" *)
  * bound_identifier
  * type_parameters option
  * (Token.t (* ":" *) * inheritance_specifiers) option
  * type_constraints option
  * protocol_body
)

and protocol_member_declaration = [
    `Body_func_decl_opt_func_body of (
        bodyless_function_declaration
      * function_body option
    )
  | `Deinit_decl of deinit_declaration
  | `Prot_prop_decl of (
        modifiers option
      * binding_kind_and_pattern
      * type_annotation option
      * type_constraints option
      * protocol_property_requirements
    )
  | `Typeas_decl of typealias_declaration
  | `Asso_decl of associatedtype_declaration
  | `Subs_decl of subscript_declaration
]

and protocol_member_declarations = (
    protocol_member_declaration
  * (semi (*tok*) * protocol_member_declaration) list (* zero or more *)
  * semi (*tok*) option
)

and raw_str_interpolation = (
    raw_str_interpolation_start (*tok*) * interpolation_contents
  * Token.t (* ")" *)
)

and repeat_while_statement = (
    Token.t (* "repeat" *)
  * Token.t (* "{" *)
  * statements option
  * Token.t (* "}" *)
  * Token.t (* "while" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
)

and simple_user_type = [
  `Rectype of (bound_identifier * type_arguments option)
]

and statements = (
    local_statement
  * (semi (*tok*) * local_statement) list (* zero or more *)
  * semi (*tok*) option
)

and string_literal = [
    `Line_str_lit of (
        Token.t (* "\"" *)
      * [
            `Line_str_content of line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Multi_line_str_lit of (
        Token.t (* "\"\"\"" *)
      * [
            `Multi_line_str_content of multi_line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"\"\"" *)
    )
  | `Raw_str_lit of (
        (
            raw_str_part (*tok*)
          * raw_str_interpolation
          * raw_str_continuing_indicator (*tok*) option
        )
          list (* zero or more *)
      * raw_str_end_part (*tok*)
    )
]

and subscript_declaration = (
    modifiers option
  * Token.t (* "subscript" *)
  * type_parameters option
  * function_value_parameters
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
  * type_constraints option
  * computed_property
)

and switch_entry = (
    modifiers option
  * [
        `Case_switch_pat_opt_where_kw_exp_rep_COMMA_switch_pat of (
            Token.t (* "case" *)
          * switch_pattern
          * where_clause option
          * (Token.t (* "," *) * switch_pattern) list (* zero or more *)
        )
      | `Defa_kw of default_keyword (*tok*)
    ]
  * Token.t (* ":" *)
  * statements
  * Token.t (* "fallthrough" *) option
)

and switch_pattern = binding_pattern_with_expr

and switch_statement = (
    Token.t (* "switch" *)
  * expression
  * Token.t (* "{" *)
  * switch_entry list (* zero or more *)
  * Token.t (* "}" *)
)

and ternary_expression = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * anon_choice_exp_764291a
)

and throw_statement = (Token.t (* "throw" *) * expression)

and tuple_expression = (
    Token.t (* "(" *)
  * (bound_identifier * Token.t (* ":" *)) option
  * expression
  * (
        Token.t (* "," *)
      * (bound_identifier * Token.t (* ":" *)) option
      * expression
    )
      list (* zero or more *)
  * Token.t (* ")" *)
)

and tuple_pattern = (
    Token.t (* "(" *)
  * tuple_pattern_item
  * (Token.t (* "," *) * tuple_pattern_item) list (* zero or more *)
  * Token.t (* ")" *)
)

and tuple_pattern_item = [
    `Simple_id_COLON_bind_pat_with_expr of (
        bound_identifier * Token.t (* ":" *) * switch_pattern
    )
  | `Bind_pat_with_expr of switch_pattern
]

and tuple_type = (
    Token.t (* "(" *)
  * (
        tuple_type_item
      * (Token.t (* "," *) * tuple_type_item) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and tuple_type_item = (
    tuple_type_item_identifier option
  * parameter_modifiers option
  * type_
)

and type_ = [ `Rectype of (type_modifiers option * unannotated_type) ]

and type_annotation = (
    Token.t (* ":" *) * possibly_implicitly_unwrapped_type
)

and type_arguments = [
  `Rectype of (
      Token.t (* "<" *)
    * type_
    * (Token.t (* "," *) * type_) list (* zero or more *)
    * Token.t (* ">" *)
  )
]

and type_casting_pattern = [
    `Is_type of (Token.t (* "is" *) * type_)
  | `Bind_pat_no_expr_as_type of (
        binding_pattern_no_expr * as_custom (*tok*) * type_
    )
]

and type_constraint = [
    `Inhe_cons of (
        attribute list (* zero or more *)
      * identifier
      * Token.t (* ":" *)
      * possibly_implicitly_unwrapped_type
    )
  | `Equa_cons of (
        attribute list (* zero or more *)
      * identifier
      * [ `Equal_sign of eq_custom (*tok*) | `Eq_eq of eq_eq_custom (*tok*) ]
      * type_
    )
]

and type_constraints = (
    where_keyword (*tok*)
  * type_constraint
  * (Token.t (* "," *) * type_constraint) list (* zero or more *)
)

and type_level_declaration = [
    `Import_decl of import_declaration
  | `Prop_decl of property_declaration
  | `Typeas_decl of typealias_declaration
  | `Func_decl of function_declaration
  | `Class_decl of class_declaration
  | `Prot_decl of protocol_declaration
  | `Deinit_decl of deinit_declaration
  | `Subs_decl of subscript_declaration
  | `Op_decl of operator_declaration
  | `Prec_group_decl of precedence_group_declaration
  | `Asso_decl of associatedtype_declaration
]

and type_modifiers = [ `Rectype of type_parameter_modifiers ]

and type_parameter = (
    type_parameter_modifiers option
  * bound_identifier
  * (Token.t (* ":" *) * type_) option
)

and type_parameter_modifiers = attribute list (* one or more *)

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and typealias_declaration = (
    modifiers option
  * modifierless_typealias_declaration
)

and unannotated_type = [
    `User_type of user_type
  | `Tuple_type of tuple_type
  | `Func_type of function_type
  | `Array_type of array_type
  | `Dict_type of dictionary_type
  | `Opt_type of (
        [
            `User_type of user_type
          | `Tuple_type of tuple_type
          | `Array_type of array_type
          | `Dict_type of dictionary_type
        ]
      * Token.t (* "?" *) list (* one or more *)
    )
  | `Meta of (
        unannotated_type
      * Token.t (* "." *)
      * [ `Type of Token.t (* "Type" *) | `Prot of Token.t (* "Protocol" *) ]
    )
  | `Opaque_type of (Token.t (* "some" *) * user_type)
  | `Prot_comp_type of (
        unannotated_type
      * (Token.t (* "&" *) * unannotated_type) list (* one or more *)
    )
]

and unary_expression = [
    `Post_exp of (expression * postfix_unary_operator)
  | `Call_exp of call_expression
  | `Cons_exp of (
        [
            `Array_type of array_type
          | `Dict_type of dictionary_type
          | `User_type of user_type
        ]
      * constructor_suffix
    )
  | `Navi_exp of navigation_expression
  | `Prefix_exp of (prefix_unary_operator * expression)
  | `As_exp of (expression * as_operator * type_)
  | `Sele_exp of (
        Token.t (* "#selector" *)
      * Token.t (* "(" *)
      * [
            `Gett of Token.t (* "getter:" *)
          | `Sett of Token.t (* "setter:" *)
        ]
          option
      * expression
      * Token.t (* ")" *)
    )
  | `Open_start_range_exp of (range_operator * expression)
  | `Open_end_range_exp of (expression * three_dot_operator_custom (*tok*))
]

and universally_allowed_pattern = [
    `Wild_pat of Token.t (* "_" *)
  | `Tuple_pat of tuple_pattern
  | `Type_cast_pat of type_casting_pattern
  | `Case_pat of (
        Token.t (* "case" *) option
      * user_type option
      * dot_custom (*tok*)
      * bound_identifier
      * tuple_pattern option
    )
]

and user_type = [
  `Rectype of (
      simple_user_type
    * (dot_custom (*tok*) * simple_user_type) list (* zero or more *)
  )
]

and value_argument = (
    type_modifiers option
  * [
        `Rep1_simple_id_COLON of
          (bound_identifier * Token.t (* ":" *)) list (* one or more *)
      | `Opt_choice_simple_id_COLON_exp of (
            (
                [
                    `Simple_id of bound_identifier
                  | `Async of Token.t (* "async" *)
                ]
              * Token.t (* ":" *)
            )
              option
          * expression
        )
    ]
)

and value_arguments = [
    `LPAR_opt_value_arg_rep_COMMA_value_arg_RPAR of
      constructor_value_arguments
  | `LBRACK_opt_value_arg_rep_COMMA_value_arg_RBRACK of (
        Token.t (* "[" *)
      * interpolation_contents option
      * Token.t (* "]" *)
    )
]

and where_clause = (where_keyword (*tok*) * expression)

and while_statement = (
    Token.t (* "while" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * Token.t (* "{" *)
  * statements option
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type global_declaration = [
    `Import_decl of import_declaration
  | `Prop_decl of property_declaration
  | `Typeas_decl of typealias_declaration
  | `Func_decl of function_declaration
  | `Class_decl of class_declaration
  | `Prot_decl of protocol_declaration
  | `Op_decl of operator_declaration
  | `Prec_group_decl of precedence_group_declaration
  | `Asso_decl of associatedtype_declaration
]
[@@deriving sexp_of]

type top_level_statement = [
    `Exp of expression
  | `Global_decl of global_declaration
  | `Labe_stmt of labeled_statement
  | `Throw_stmt of throw_statement
]
[@@deriving sexp_of]

type source_file = (
    shebang_line option
  * (
        top_level_statement
      * (semi (*tok*) * top_level_statement) list (* zero or more *)
      * semi (*tok*) option
    )
      option
)
[@@deriving sexp_of]

type await_operator (* inlined *) = Token.t (* "await" *)
[@@deriving sexp_of]

type self_expression (* inlined *) = Token.t (* "self" *)
[@@deriving sexp_of]

type use_site_target (* inlined *) = (
    [
        `Prop of Token.t (* "property" *)
      | `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Rece of Token.t (* "receiver" *)
      | `Param of Token.t (* "param" *)
      | `Setp of Token.t (* "setparam" *)
      | `Dele of Token.t (* "delegate" *)
    ]
  * Token.t (* ":" *)
)
[@@deriving sexp_of]

type wildcard_pattern (* inlined *) = Token.t (* "_" *)
[@@deriving sexp_of]

type throw_keyword (* inlined *) = Token.t (* "throw" *)
[@@deriving sexp_of]

type property_behavior_modifier (* inlined *) = Token.t (* "lazy" *)
[@@deriving sexp_of]

type super_expression (* inlined *) = Token.t (* "super" *)
[@@deriving sexp_of]

type visibility_modifier (* inlined *) = (
    [
        `Public of Token.t (* "public" *)
      | `Priv of Token.t (* "private" *)
      | `Inte of Token.t (* "internal" *)
      | `File of Token.t (* "fileprivate" *)
      | `Open of Token.t (* "open" *)
    ]
  * (Token.t (* "(" *) * Token.t (* "set" *) * Token.t (* ")" *)) option
)
[@@deriving sexp_of]

type is_operator (* inlined *) = Token.t (* "is" *)
[@@deriving sexp_of]

type multiline_comment (* inlined *) = Token.t
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type diagnostic (* inlined *) = Token.t
[@@deriving sexp_of]

type immediate_quest (* inlined *) = Token.t (* "?" *)
[@@deriving sexp_of]

type quest (* inlined *) = Token.t (* "?" *)
[@@deriving sexp_of]

type directive (* inlined *) = Token.t
[@@deriving sexp_of]

type arrow_operator (* inlined *) = arrow_operator_custom (*tok*)
[@@deriving sexp_of]

type conjunction_operator (* inlined *) = conjunction_operator_custom (*tok*)
[@@deriving sexp_of]

type async_keyword (* inlined *) = async_keyword_custom (*tok*)
[@@deriving sexp_of]

type as_ (* inlined *) = as_custom (*tok*)
[@@deriving sexp_of]

type open_ended_range_operator (* inlined *) =
  open_ended_range_operator_custom (*tok*)
[@@deriving sexp_of]

type as_quest (* inlined *) = as_quest_custom (*tok*)
[@@deriving sexp_of]

type class_member_separator (* inlined *) = semi (*tok*)
[@@deriving sexp_of]

type uni_character_literal (* inlined *) = (
    Token.t (* "\\" *) * Token.t (* "u" *) * pat_888b548 (*tok*)
)
[@@deriving sexp_of]

type semgrep_ellipsis (* inlined *) = three_dot_operator_custom (*tok*)
[@@deriving sexp_of]

type three_dot_operator (* inlined *) = three_dot_operator_custom (*tok*)
[@@deriving sexp_of]

type nil_coalescing_operator (* inlined *) =
  nil_coalescing_operator_custom (*tok*)
[@@deriving sexp_of]

type disjunction_operator (* inlined *) = disjunction_operator_custom (*tok*)
[@@deriving sexp_of]

type equal_sign (* inlined *) = eq_custom (*tok*)
[@@deriving sexp_of]

type dot (* inlined *) = dot_custom (*tok*)
[@@deriving sexp_of]

type as_bang (* inlined *) = as_bang_custom (*tok*)
[@@deriving sexp_of]

type eq_eq (* inlined *) = eq_eq_custom (*tok*)
[@@deriving sexp_of]

type modifier (* inlined *) = [
    `Non_local_scope_modi of non_local_scope_modifier
  | `Loca_perm_modi of locally_permitted_modifier
]
[@@deriving sexp_of]

type anon_rep1_bound_id_int_lit_rep_DOT_int_lit_bb9c01b (* inlined *) = (
    bound_identifier list (* one or more *)
  * integer_literal (*tok*)
  * (Token.t (* "." *) * integer_literal (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type availability_condition (* inlined *) = (
    Token.t (* "#available" *)
  * Token.t (* "(" *)
  * availability_argument
  * (Token.t (* "," *) * availability_argument) list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type additive_expression (* inlined *) = (
    expression * additive_operator * expression
)
[@@deriving sexp_of]

type array_literal (* inlined *) = (
    Token.t (* "[" *)
  * (expression * (Token.t (* "," *) * expression) list (* zero or more *))
      option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type as_expression (* inlined *) = (expression * as_operator * type_)
[@@deriving sexp_of]

type await_expression (* inlined *) = (
    Token.t (* "await" *)
  * [
        `Exp of expression
      | `Call_exp of call_expression
      | `Tern_exp of ternary_expression
    ]
)
[@@deriving sexp_of]

type bitwise_operation (* inlined *) = (
    expression * bitwise_binary_operator * expression
)
[@@deriving sexp_of]

type case_pattern (* inlined *) = (
    Token.t (* "case" *) option
  * user_type option
  * dot_custom (*tok*)
  * bound_identifier
  * tuple_pattern option
)
[@@deriving sexp_of]

type check_expression (* inlined *) = (
    expression * Token.t (* "is" *) * type_
)
[@@deriving sexp_of]

type comparison_expression (* inlined *) = (
    expression * comparison_operator * expression
)
[@@deriving sexp_of]

type conjunction_expression (* inlined *) = (
    expression * conjunction_operator_custom (*tok*)
  * anon_choice_exp_764291a
)
[@@deriving sexp_of]

type constructor_expression (* inlined *) = (
    [
        `Array_type of array_type
      | `Dict_type of dictionary_type
      | `User_type of user_type
    ]
  * constructor_suffix
)
[@@deriving sexp_of]

type dictionary_literal (* inlined *) = (
    Token.t (* "[" *)
  * [
        `COLON of Token.t (* ":" *)
      | `Dict_lit_item_rep_COMMA_dict_lit_item of (
            dictionary_literal_item
          * (Token.t (* "," *) * dictionary_literal_item)
              list (* zero or more *)
        )
    ]
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type disjunction_expression (* inlined *) = (
    expression * disjunction_operator_custom (*tok*) * expression
)
[@@deriving sexp_of]

type enum_type_parameters (* inlined *) = (
    Token.t (* "(" *)
  * (
        tuple_type_item_identifier option
      * type_
      * (eq_custom (*tok*) * expression) option
      * (
            Token.t (* "," *)
          * tuple_type_item_identifier option
          * type_
          * (eq_custom (*tok*) * expression) option
        )
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type equality_constraint (* inlined *) = (
    attribute list (* zero or more *)
  * identifier
  * [ `Equal_sign of eq_custom (*tok*) | `Eq_eq of eq_eq_custom (*tok*) ]
  * type_
)
[@@deriving sexp_of]

type equality_expression (* inlined *) = (
    expression * equality_operator * expression
)
[@@deriving sexp_of]

type expr_hack_at_ternary_binary_call (* inlined *) = (
    expression * expr_hack_at_ternary_binary_call_suffix
)
[@@deriving sexp_of]

type if_let_binding (* inlined *) = (
    direct_or_indirect_binding * eq_custom (*tok*) * expression
)
[@@deriving sexp_of]

type infix_expression (* inlined *) = (
    expression * custom_operator * expression
)
[@@deriving sexp_of]

type inheritance_constraint (* inlined *) = (
    attribute list (* zero or more *)
  * identifier
  * Token.t (* ":" *)
  * possibly_implicitly_unwrapped_type
)
[@@deriving sexp_of]

type key_path_expression (* inlined *) = (
    Token.t (* "\\" *)
  * [
        `Simple_user_type of simple_user_type
      | `Array_type of array_type
      | `Dict_type of dictionary_type
    ]
      option
  * (Token.t (* "." *) * key_path_component) list (* zero or more *)
)
[@@deriving sexp_of]

type key_path_string_expression (* inlined *) = (
    Token.t (* "#keyPath" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type line_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [ `Line_str_content of line_string_content | `Interp of interpolation ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type local_class_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_class_declaration
)
[@@deriving sexp_of]

type local_function_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_function_declaration
)
[@@deriving sexp_of]

type local_property_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_property_declaration
)
[@@deriving sexp_of]

type local_typealias_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_typealias_declaration
)
[@@deriving sexp_of]

type metatype (* inlined *) = (
    unannotated_type
  * Token.t (* "." *)
  * [ `Type of Token.t (* "Type" *) | `Prot of Token.t (* "Protocol" *) ]
)
[@@deriving sexp_of]

type multi_line_string_literal (* inlined *) = (
    Token.t (* "\"\"\"" *)
  * [
        `Multi_line_str_content of multi_line_string_content
      | `Interp of interpolation
    ]
      list (* zero or more *)
  * Token.t (* "\"\"\"" *)
)
[@@deriving sexp_of]

type multiplicative_expression (* inlined *) = (
    expression * multiplicative_operator * expression
)
[@@deriving sexp_of]

type nil_coalescing_expression (* inlined *) = (
    expression * nil_coalescing_operator_custom (*tok*) * expression
)
[@@deriving sexp_of]

type opaque_type (* inlined *) = (Token.t (* "some" *) * user_type)
[@@deriving sexp_of]

type open_end_range_expression (* inlined *) = (
    expression * three_dot_operator_custom (*tok*)
)
[@@deriving sexp_of]

type open_start_range_expression (* inlined *) = (
    range_operator * expression
)
[@@deriving sexp_of]

type optional_type (* inlined *) = (
    [
        `User_type of user_type
      | `Tuple_type of tuple_type
      | `Array_type of array_type
      | `Dict_type of dictionary_type
    ]
  * Token.t (* "?" *) list (* one or more *)
)
[@@deriving sexp_of]

type playground_literal (* inlined *) = (
    [
        `HASH_38ce0d0 of Token.t (* "#colorLiteral" *)
      | `HASH_34ae46a of Token.t (* "#fileLiteral" *)
      | `HASH_71f9c0e of Token.t (* "#imageLiteral" *)
    ]
  * Token.t (* "(" *)
  * bound_identifier
  * Token.t (* ":" *)
  * expression
  * (Token.t (* "," *) * bound_identifier * Token.t (* ":" *) * expression)
      list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type postfix_expression (* inlined *) = (expression * postfix_unary_operator)
[@@deriving sexp_of]

type prefix_expression (* inlined *) = (prefix_unary_operator * expression)
[@@deriving sexp_of]

type protocol_composition_type (* inlined *) = (
    unannotated_type
  * (Token.t (* "&" *) * unannotated_type) list (* one or more *)
)
[@@deriving sexp_of]

type protocol_property_declaration (* inlined *) = (
    modifiers option
  * binding_kind_and_pattern
  * type_annotation option
  * type_constraints option
  * protocol_property_requirements
)
[@@deriving sexp_of]

type range_expression (* inlined *) = (
    expression * range_operator * expression
)
[@@deriving sexp_of]

type raw_string_literal (* inlined *) = (
    (
        raw_str_part (*tok*)
      * raw_str_interpolation
      * raw_str_continuing_indicator (*tok*) option
    )
      list (* zero or more *)
  * raw_str_end_part (*tok*)
)
[@@deriving sexp_of]

type selector_expression (* inlined *) = (
    Token.t (* "#selector" *)
  * Token.t (* "(" *)
  * [ `Gett of Token.t (* "getter:" *) | `Sett of Token.t (* "setter:" *) ]
      option
  * expression
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type try_expression (* inlined *) = (
    try_operator
  * [
        `Exp of expression
      | `Bin_exp of binary_expression
      | `Call_exp of call_expression
      | `Tern_exp of ternary_expression
    ]
)
[@@deriving sexp_of]

type non_binding_pattern_with_expr (* inlined *) = (
    [ `Univ_allo_pat of universally_allowed_pattern | `Exp of expression ]
  * Token.t (* "?" *) option
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout
